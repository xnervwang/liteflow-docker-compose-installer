services:
  liteflow:
    profiles: ["liteflow"]
    build:
      context: https://github.com/xnervwang/liteflow.git#master
      args:
        # Don't use `local` otherwise Liteflow/Dockerfile would run `mv /tmp/Liteflow /source/Liteflow`,
        # which just moves a repo snapshot which doesn't have .git subfolder, and further `git submodule`
        # command would fail. The repo snapshot is generated by the `context`.
        SOURCE: https://github.com/xnervwang/Liteflow.git
        BRANCH: master
    image: liteflow:master
    # 只影响是否去Registry拉镜像，不影响本地构建。如果已有同名本地镜像，即使git repo有修改，
    # 也不会重新构建镜像。 如果需要强制重新build，请使用--build选项，例如：
    # docker compose -f docker-compose.yml up -d --build
    pull_policy: never          # 避免先尝试拉取远端镜像
    depends_on:
      liteflow-conf-puller:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "[ -s /app/etc/${CONF_FILE} ] && pidof liteflow >/dev/null || exit 1"]
      interval: 5s
      timeout: 3s
      retries: 5
      start_period: 20s
    network_mode: host
    init: true
    environment:
      TZ: ${TZ}
      confpath: /app/etc/${CONF_FILE}
    volumes:
      # Don't mount the file directly, otherwise before puller gets the file, docker would create
      # a folder with the conf file path wrongly.
      # TODO: should use a sub folder which only has conf file.
      - ${CONF_DIR}:/app/etc:ro
    restart: unless-stopped

  liteflow-conf-watcher:
    profiles: ["watcher"]
    build:
      context: https://github.com/xnervwang/liteflow-conf-watcher-docker.git#main
    image: xnervwang/liteflow-conf-watcher:main
    pull_policy: never
    depends_on:
      liteflow-conf-puller:
        condition: service_healthy
      liteflow:
        condition: service_healthy
      dockerproxy:
        condition: service_started
    # 不要使用host网络，否则无法连接dockerproxy，因为后者不使用host网络。
    healthcheck:
      test:
        - CMD-SHELL
        - |
          set -e
          [ -s /app/etc/${CONF_FILE} ] || exit 1
          # docker-socket-proxy 的标准 _ping 接口应返回 "OK"
          wget -qO- http://dockerproxy:2375/_ping | grep -q '^OK$'
      interval: 15s
      timeout: 3s
      retries: 5
      start_period: 10s
    environment:
      TZ: ${TZ}
      DOCKER_API: ${DOCKER_API}
      TARGET: "${COMPOSE_PROJECT_NAME}-liteflow-1"
      CONF_FILE: /app/etc/${CONF_FILE}
    volumes:
      # 必须映射整个目录，不能仅映射单个liteflow.conf文件，否则mv等动作无法被捕捉。
      - ${CONF_DIR}:/app/etc:ro
    restart: unless-stopped
    
  liteflow-conf-puller:
    profiles: ["puller"]
    build:
      context: https://github.com/xnervwang/liteflow-conf-puller-docker.git#main
    image: xnervwang/liteflow-conf-puller:main
    pull_policy: never
    healthcheck:
      test: ["CMD-SHELL","[ -s /app/etc/${CONF_FILE} ] && [ -f ${PULLER_READY_FLAG} ]"]
      interval: 5s
      timeout: 3s
      retries: 5
      start_period: 10s
    environment:
      TZ: ${TZ}
      # —— 运行模式（git）：——
      CONF_REPO: ${CONF_REPO}
      CONF_SRC: output/${HOSTNAME}.conf
      DEST_FILE: /app/etc/${CONF_FILE}
      INTERVAL: "${INTERVAL}"
      READY_FLAG: ${PULLER_READY_FLAG}
      # BACKUP: "1"                                  # 可选：覆盖前备份
      FORCE: "1"                                   # 可选：未开启 BACKUP 时允许覆盖
    volumes:
      - ${CONF_DIR}:/app/etc:rw
      - ${HOME}/.ssh:/root/.ssh:ro
    restart: unless-stopped

  ss-local:
    profiles: ["ss-local"]
    image: shadowsocks/shadowsocks-libev:latest
    network_mode: host
    environment:
      TZ: ${TZ}
      SERVER_ADDR: ${SS_LOCAL_SERVER_ADDR}
      SERVER_PORT: "${SS_LOCAL_SERVER_PORT}"
      LOCAL_ADDR: ${SS_LOCAL_ADDR}
      LOCAL_PORT: "${SS_LOCAL_PORT}"
      PASSWORD: ${SS_PASSWORD}
      METHOD: ${SS_METHOD}
      TIMEOUT: "${SS_LOCAL_TIMEOUT}"
    healthcheck:
      test:
        - CMD-SHELL
        - |
          # 检查 TCP 监听：/proc/net/tcp{,6} 中状态 0A=LISTEN
          hex=$(printf "%04X" ${SS_LOCAL_PORT:-8387})
          awk -v h="$hex" 'NR>1{split($2,a,":"); if(a[2]==h && $4=="0A") f=1} END{exit f?0:1}' /proc/net/tcp /proc/net/tcp6
      interval: 15s
      timeout: 3s
      retries: 5
      start_period: 5s
    entrypoint: |
      /bin/sh -eu -c '
      : "$${SERVER_ADDR:?required}"
      : "$${SERVER_PORT:?required}"
      : "$${LOCAL_ADDR:?required}"
      : "$${LOCAL_PORT:?required}"
      : "$${PASSWORD:?required}"
      : "$${METHOD:?required}"
      : "$${TIMEOUT:?required}"
      cat > /tmp/config.json <<EOF
      {
          "server":"$${SERVER_ADDR}",
          "server_port":$${SERVER_PORT:-8388},
          "local_address":"$${LOCAL_ADDR}",
          "local_port":$${LOCAL_PORT:-8387},
          "password":"$${PASSWORD}",
          "timeout":$${TIMEOUT:-300},
          "method":"$${METHOD}"
      }
      EOF
      exec ss-local -c /tmp/config.json
      '
    restart: unless-stopped

  ss-server:
    profiles: ["ss-server"]
    image: shadowsocks/shadowsocks-libev:latest
    network_mode: host
    healthcheck:
      test:
        - CMD-SHELL
        - |
          hex=$(printf "%04X" ${SS_SERVER_PORT:-8388})
          awk -v h="$hex" 'NR>1{split($2,a,":"); if(a[2]==h && $4=="0A") f=1} END{exit f?0:1}' /proc/net/tcp /proc/net/tcp6
      interval: 15s
      timeout: 3s
      retries: 5
      start_period: 5s
    environment:
      TZ: ${TZ}
      SERVER_ADDR: ${SS_SERVER_BIND_ADDR}
      SERVER_PORT: "${SS_SERVER_PORT}"
      PASSWORD: ${SS_PASSWORD}
      METHOD: ${SS_METHOD}
      TIMEOUT: "${SS_SERVER_TIMEOUT}"
      ARGS: ${SS_SERVER_ARGS}
    restart: unless-stopped

  dockerproxy:
    profiles: ["proxy"]
    # 因为标签名不变，所以当docker hub上该标签发生变动时，本地并不会重新拉取，除非用
    # docker compose up -d --pull always强制重新拉取。 
    image: tecnativa/docker-socket-proxy:latest
    # 不要使用host网络，避免将docker控制面暴露于host网络。
    environment:
      TZ: ${TZ}
      LOG_LEVEL: ${DOCKERPROXY_LOG_LEVEL}
      CONTAINERS: "1"
      POST: "1"
      CONTAINERS_KILL: "1"
    healthcheck:
      test:
        - CMD-SHELL
        - |
          wget -qO- http://127.0.0.1:2375/_ping | grep -q '^OK$'
      interval: 15s
      timeout: 3s
      retries: 5
      start_period: 5s
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    restart: unless-stopped

  ddns-go:
    profiles: ["ddns-go"]
    build:
      context: https://github.com/xnervwang/ddns-go-docker.git#main
    image: xnervwang/ddns-go-docker:main
    pull_policy: never
    # 必须 host 模式，private IPv4 才能取到宿主机内网 IP
    network_mode: host
    healthcheck:
      test: ["CMD-SHELL", "pidof ddns-go >/dev/null"]
      interval: 30s
      timeout: 3s
      retries: 5
      start_period: 10s
    environment:
      TZ: ${DDNS_GO_TZ}
      LANG: ${DDNS_GO_LANG}
      NOT_ALLOW_WAN_ACCESS: "true"

      # —— 公网（A/AAAA 只启用 IPv4；IPv6 先关）——
      PUBLIC_PROFILE_NAME: ${DDNS_GO_PUBLIC_PROFILE_NAME}
      PUBLIC_IPV4_ENABLE: "true"
      PUBLIC_IPV4_GETTYPE: "url"
      PUBLIC_IPV4_URLS: ${DDNS_GO_PUBLIC_IPV4_URLS}
      PUBLIC_IPV4_DOMAIN: ${PUBLIC_IPV4_DOMAIN}
      PUBLIC_IPV6_ENABLE: "false"

      PUBLIC_DNS_NAME: ${DDNS_GO_DNS_NAME}
      PUBLIC_DNS_ID: ${DDNS_GO_ALIDNS_ID}
      PUBLIC_DNS_SECRET: ${DDNS_GO_ALIDNS_SECRET}

      # —— 内网（只启用 IPv4，走网卡获取）——
      PRIVATE_PROFILE_NAME: ${DDNS_GO_PRIVATE_PROFILE_NAME}
      PRIVATE_IPV4_ENABLE: "true"
      PRIVATE_IPV4_GETTYPE: "netInterface"
      PRIVATE_IPV4_NETINTERFACE: ${DDNS_GO_PRIVATE_IPV4_NETINTERFACE}
      PRIVATE_IPV4_DOMAIN: ${PRIVATE_IPV4_DOMAIN}
      PRIVATE_IPV6_ENABLE: "false"

      PRIVATE_DNS_NAME: ${DDNS_GO_DNS_NAME}
      PRIVATE_DNS_ID: ${DDNS_GO_ALIDNS_ID}
      PRIVATE_DNS_SECRET: ${DDNS_GO_ALIDNS_SECRET}
      # —— Web 登录（必需：用户名与 bcrypt 哈希）——
      WEB_USERNAME: ${DDNS_GO_WEB_USERNAME}
      WEB_PASSWORD_HASH: ${DDNS_GO_WEB_PASSWORD_HASH}
    restart: unless-stopped

  stunnel:
    profiles: ["stunnel"]
    build:
      context: https://github.com/xnervwang/stunnel5-docker.git#main
    image: xnervwang/stunnel5-docker:main
    pull_policy: never
    network_mode: host
    cap_add:
      - NET_BIND_SERVICE
    healthcheck:
      test:
        - CMD-SHELL
        - |
          hex=$(printf "%04X" ${STUNNEL_ACCEPT##*:})
          awk -v h="$hex" 'NR>1{split($2,a,":"); if(a[2]==h && $4=="0A") f=1} END{exit f?0:1}' /proc/net/tcp /proc/net/tcp6
      interval: 15s
      timeout: 3s
      retries: 5
      start_period: 5s
    environment:
      STUNNEL_SERVICE_NAME: ${STUNNEL_SERVICE_NAME}
      STUNNEL_CLIENT: ${STUNNEL_CLIENT}
      STUNNEL_ACCEPT: ${STUNNEL_ACCEPT}
      STUNNEL_CONNECT: ${STUNNEL_CONNECT}
      STUNNEL_CERT: ${STUNNEL_CERT}
      STUNNEL_KEY: ${STUNNEL_KEY}
      STUNNEL_CAFILE: ${STUNNEL_CAFILE}
      STUNNEL_RUN_AS_ROOT: "yes"
    volumes:
      - ${CONF_DIR}/stunnel.pem:/app/etc/stunnel.pem:ro
    restart: unless-stopped

  xray:
    profiles: ["xray"]
    build:
      context: https://github.com/xnervwang/xray-docker.git#main
    image: xnervwang/xray:latest
    network_mode: host
    environment:
      XRAY_LOG_LEVEL: ${XRAY_LOG_LEVEL}
      XRAY_LISTEN_PORT: "${XRAY_LISTEN_PORT}"
      XRAY_LISTEN_IP: ${XRAY_LISTEN_IP}
      XRAY_LISTEN_PROTOCOL: ${XRAY_LISTEN_PROTOCOL}
      XRAY_OUTBOUND_PROTOCOL: ${XRAY_OUTBOUND_PROTOCOL}
      XRAY_OUTBOUND_IP: ${XRAY_OUTBOUND_IP}
      XRAY_OUTBOUND_PORT: "${XRAY_OUTBOUND_PORT}"
      XRAY_RULE_PRIVATE_IP: ${XRAY_RULE_PRIVATE_IP}
      XRAY_RULE_PROXY_SITE: ${XRAY_RULE_PROXY_SITE}
      XRAY_RULE_PROXY_IP: ${XRAY_RULE_PROXY_IP}
    healthcheck:
      test:
        - CMD-SHELL
        - |
          bash -lc '
            hex=$(printf "%04X" $${LISTEN_PORT:-1080})
            awk -v h="$hex" "NR>1{split(\$2,a,\":\"); if(a[2]==h && \$4==\"0A\") f=1} END{exit f?0:1}" /proc/net/tcp /proc/net/tcp6
          '
      interval: 15s
      timeout: 3s
      retries: 10
      start_period: 10s
    restart: unless-stopped
